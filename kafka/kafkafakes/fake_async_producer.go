// Code generated by counterfeiter. DO NOT EDIT.
package kafkafakes

import (
	"sync"

	"github.com/IBM/sarama"
	"github.com/ehsaniara/delay-box/kafka"
)

type FakeAsyncProducer struct {
	AbortTxnStub        func() error
	abortTxnMutex       sync.RWMutex
	abortTxnArgsForCall []struct {
	}
	abortTxnReturns struct {
		result1 error
	}
	abortTxnReturnsOnCall map[int]struct {
		result1 error
	}
	AddMessageToTxnStub        func(*sarama.ConsumerMessage, string, *string) error
	addMessageToTxnMutex       sync.RWMutex
	addMessageToTxnArgsForCall []struct {
		arg1 *sarama.ConsumerMessage
		arg2 string
		arg3 *string
	}
	addMessageToTxnReturns struct {
		result1 error
	}
	addMessageToTxnReturnsOnCall map[int]struct {
		result1 error
	}
	AddOffsetsToTxnStub        func(map[string][]*sarama.PartitionOffsetMetadata, string) error
	addOffsetsToTxnMutex       sync.RWMutex
	addOffsetsToTxnArgsForCall []struct {
		arg1 map[string][]*sarama.PartitionOffsetMetadata
		arg2 string
	}
	addOffsetsToTxnReturns struct {
		result1 error
	}
	addOffsetsToTxnReturnsOnCall map[int]struct {
		result1 error
	}
	AsyncCloseStub        func()
	asyncCloseMutex       sync.RWMutex
	asyncCloseArgsForCall []struct {
	}
	BeginTxnStub        func() error
	beginTxnMutex       sync.RWMutex
	beginTxnArgsForCall []struct {
	}
	beginTxnReturns struct {
		result1 error
	}
	beginTxnReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CommitTxnStub        func() error
	commitTxnMutex       sync.RWMutex
	commitTxnArgsForCall []struct {
	}
	commitTxnReturns struct {
		result1 error
	}
	commitTxnReturnsOnCall map[int]struct {
		result1 error
	}
	ErrorsStub        func() <-chan *sarama.ProducerError
	errorsMutex       sync.RWMutex
	errorsArgsForCall []struct {
	}
	errorsReturns struct {
		result1 <-chan *sarama.ProducerError
	}
	errorsReturnsOnCall map[int]struct {
		result1 <-chan *sarama.ProducerError
	}
	InputStub        func() chan<- *sarama.ProducerMessage
	inputMutex       sync.RWMutex
	inputArgsForCall []struct {
	}
	inputReturns struct {
		result1 chan<- *sarama.ProducerMessage
	}
	inputReturnsOnCall map[int]struct {
		result1 chan<- *sarama.ProducerMessage
	}
	IsTransactionalStub        func() bool
	isTransactionalMutex       sync.RWMutex
	isTransactionalArgsForCall []struct {
	}
	isTransactionalReturns struct {
		result1 bool
	}
	isTransactionalReturnsOnCall map[int]struct {
		result1 bool
	}
	SuccessesStub        func() <-chan *sarama.ProducerMessage
	successesMutex       sync.RWMutex
	successesArgsForCall []struct {
	}
	successesReturns struct {
		result1 <-chan *sarama.ProducerMessage
	}
	successesReturnsOnCall map[int]struct {
		result1 <-chan *sarama.ProducerMessage
	}
	TxnStatusStub        func() sarama.ProducerTxnStatusFlag
	txnStatusMutex       sync.RWMutex
	txnStatusArgsForCall []struct {
	}
	txnStatusReturns struct {
		result1 sarama.ProducerTxnStatusFlag
	}
	txnStatusReturnsOnCall map[int]struct {
		result1 sarama.ProducerTxnStatusFlag
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAsyncProducer) AbortTxn() error {
	fake.abortTxnMutex.Lock()
	ret, specificReturn := fake.abortTxnReturnsOnCall[len(fake.abortTxnArgsForCall)]
	fake.abortTxnArgsForCall = append(fake.abortTxnArgsForCall, struct {
	}{})
	stub := fake.AbortTxnStub
	fakeReturns := fake.abortTxnReturns
	fake.recordInvocation("AbortTxn", []interface{}{})
	fake.abortTxnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) AbortTxnCallCount() int {
	fake.abortTxnMutex.RLock()
	defer fake.abortTxnMutex.RUnlock()
	return len(fake.abortTxnArgsForCall)
}

func (fake *FakeAsyncProducer) AbortTxnCalls(stub func() error) {
	fake.abortTxnMutex.Lock()
	defer fake.abortTxnMutex.Unlock()
	fake.AbortTxnStub = stub
}

func (fake *FakeAsyncProducer) AbortTxnReturns(result1 error) {
	fake.abortTxnMutex.Lock()
	defer fake.abortTxnMutex.Unlock()
	fake.AbortTxnStub = nil
	fake.abortTxnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AbortTxnReturnsOnCall(i int, result1 error) {
	fake.abortTxnMutex.Lock()
	defer fake.abortTxnMutex.Unlock()
	fake.AbortTxnStub = nil
	if fake.abortTxnReturnsOnCall == nil {
		fake.abortTxnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.abortTxnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AddMessageToTxn(arg1 *sarama.ConsumerMessage, arg2 string, arg3 *string) error {
	fake.addMessageToTxnMutex.Lock()
	ret, specificReturn := fake.addMessageToTxnReturnsOnCall[len(fake.addMessageToTxnArgsForCall)]
	fake.addMessageToTxnArgsForCall = append(fake.addMessageToTxnArgsForCall, struct {
		arg1 *sarama.ConsumerMessage
		arg2 string
		arg3 *string
	}{arg1, arg2, arg3})
	stub := fake.AddMessageToTxnStub
	fakeReturns := fake.addMessageToTxnReturns
	fake.recordInvocation("AddMessageToTxn", []interface{}{arg1, arg2, arg3})
	fake.addMessageToTxnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) AddMessageToTxnCallCount() int {
	fake.addMessageToTxnMutex.RLock()
	defer fake.addMessageToTxnMutex.RUnlock()
	return len(fake.addMessageToTxnArgsForCall)
}

func (fake *FakeAsyncProducer) AddMessageToTxnCalls(stub func(*sarama.ConsumerMessage, string, *string) error) {
	fake.addMessageToTxnMutex.Lock()
	defer fake.addMessageToTxnMutex.Unlock()
	fake.AddMessageToTxnStub = stub
}

func (fake *FakeAsyncProducer) AddMessageToTxnArgsForCall(i int) (*sarama.ConsumerMessage, string, *string) {
	fake.addMessageToTxnMutex.RLock()
	defer fake.addMessageToTxnMutex.RUnlock()
	argsForCall := fake.addMessageToTxnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAsyncProducer) AddMessageToTxnReturns(result1 error) {
	fake.addMessageToTxnMutex.Lock()
	defer fake.addMessageToTxnMutex.Unlock()
	fake.AddMessageToTxnStub = nil
	fake.addMessageToTxnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AddMessageToTxnReturnsOnCall(i int, result1 error) {
	fake.addMessageToTxnMutex.Lock()
	defer fake.addMessageToTxnMutex.Unlock()
	fake.AddMessageToTxnStub = nil
	if fake.addMessageToTxnReturnsOnCall == nil {
		fake.addMessageToTxnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addMessageToTxnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AddOffsetsToTxn(arg1 map[string][]*sarama.PartitionOffsetMetadata, arg2 string) error {
	fake.addOffsetsToTxnMutex.Lock()
	ret, specificReturn := fake.addOffsetsToTxnReturnsOnCall[len(fake.addOffsetsToTxnArgsForCall)]
	fake.addOffsetsToTxnArgsForCall = append(fake.addOffsetsToTxnArgsForCall, struct {
		arg1 map[string][]*sarama.PartitionOffsetMetadata
		arg2 string
	}{arg1, arg2})
	stub := fake.AddOffsetsToTxnStub
	fakeReturns := fake.addOffsetsToTxnReturns
	fake.recordInvocation("AddOffsetsToTxn", []interface{}{arg1, arg2})
	fake.addOffsetsToTxnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) AddOffsetsToTxnCallCount() int {
	fake.addOffsetsToTxnMutex.RLock()
	defer fake.addOffsetsToTxnMutex.RUnlock()
	return len(fake.addOffsetsToTxnArgsForCall)
}

func (fake *FakeAsyncProducer) AddOffsetsToTxnCalls(stub func(map[string][]*sarama.PartitionOffsetMetadata, string) error) {
	fake.addOffsetsToTxnMutex.Lock()
	defer fake.addOffsetsToTxnMutex.Unlock()
	fake.AddOffsetsToTxnStub = stub
}

func (fake *FakeAsyncProducer) AddOffsetsToTxnArgsForCall(i int) (map[string][]*sarama.PartitionOffsetMetadata, string) {
	fake.addOffsetsToTxnMutex.RLock()
	defer fake.addOffsetsToTxnMutex.RUnlock()
	argsForCall := fake.addOffsetsToTxnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAsyncProducer) AddOffsetsToTxnReturns(result1 error) {
	fake.addOffsetsToTxnMutex.Lock()
	defer fake.addOffsetsToTxnMutex.Unlock()
	fake.AddOffsetsToTxnStub = nil
	fake.addOffsetsToTxnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AddOffsetsToTxnReturnsOnCall(i int, result1 error) {
	fake.addOffsetsToTxnMutex.Lock()
	defer fake.addOffsetsToTxnMutex.Unlock()
	fake.AddOffsetsToTxnStub = nil
	if fake.addOffsetsToTxnReturnsOnCall == nil {
		fake.addOffsetsToTxnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addOffsetsToTxnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) AsyncClose() {
	fake.asyncCloseMutex.Lock()
	fake.asyncCloseArgsForCall = append(fake.asyncCloseArgsForCall, struct {
	}{})
	stub := fake.AsyncCloseStub
	fake.recordInvocation("AsyncClose", []interface{}{})
	fake.asyncCloseMutex.Unlock()
	if stub != nil {
		fake.AsyncCloseStub()
	}
}

func (fake *FakeAsyncProducer) AsyncCloseCallCount() int {
	fake.asyncCloseMutex.RLock()
	defer fake.asyncCloseMutex.RUnlock()
	return len(fake.asyncCloseArgsForCall)
}

func (fake *FakeAsyncProducer) AsyncCloseCalls(stub func()) {
	fake.asyncCloseMutex.Lock()
	defer fake.asyncCloseMutex.Unlock()
	fake.AsyncCloseStub = stub
}

func (fake *FakeAsyncProducer) BeginTxn() error {
	fake.beginTxnMutex.Lock()
	ret, specificReturn := fake.beginTxnReturnsOnCall[len(fake.beginTxnArgsForCall)]
	fake.beginTxnArgsForCall = append(fake.beginTxnArgsForCall, struct {
	}{})
	stub := fake.BeginTxnStub
	fakeReturns := fake.beginTxnReturns
	fake.recordInvocation("BeginTxn", []interface{}{})
	fake.beginTxnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) BeginTxnCallCount() int {
	fake.beginTxnMutex.RLock()
	defer fake.beginTxnMutex.RUnlock()
	return len(fake.beginTxnArgsForCall)
}

func (fake *FakeAsyncProducer) BeginTxnCalls(stub func() error) {
	fake.beginTxnMutex.Lock()
	defer fake.beginTxnMutex.Unlock()
	fake.BeginTxnStub = stub
}

func (fake *FakeAsyncProducer) BeginTxnReturns(result1 error) {
	fake.beginTxnMutex.Lock()
	defer fake.beginTxnMutex.Unlock()
	fake.BeginTxnStub = nil
	fake.beginTxnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) BeginTxnReturnsOnCall(i int, result1 error) {
	fake.beginTxnMutex.Lock()
	defer fake.beginTxnMutex.Unlock()
	fake.BeginTxnStub = nil
	if fake.beginTxnReturnsOnCall == nil {
		fake.beginTxnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.beginTxnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeAsyncProducer) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeAsyncProducer) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) CommitTxn() error {
	fake.commitTxnMutex.Lock()
	ret, specificReturn := fake.commitTxnReturnsOnCall[len(fake.commitTxnArgsForCall)]
	fake.commitTxnArgsForCall = append(fake.commitTxnArgsForCall, struct {
	}{})
	stub := fake.CommitTxnStub
	fakeReturns := fake.commitTxnReturns
	fake.recordInvocation("CommitTxn", []interface{}{})
	fake.commitTxnMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) CommitTxnCallCount() int {
	fake.commitTxnMutex.RLock()
	defer fake.commitTxnMutex.RUnlock()
	return len(fake.commitTxnArgsForCall)
}

func (fake *FakeAsyncProducer) CommitTxnCalls(stub func() error) {
	fake.commitTxnMutex.Lock()
	defer fake.commitTxnMutex.Unlock()
	fake.CommitTxnStub = stub
}

func (fake *FakeAsyncProducer) CommitTxnReturns(result1 error) {
	fake.commitTxnMutex.Lock()
	defer fake.commitTxnMutex.Unlock()
	fake.CommitTxnStub = nil
	fake.commitTxnReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) CommitTxnReturnsOnCall(i int, result1 error) {
	fake.commitTxnMutex.Lock()
	defer fake.commitTxnMutex.Unlock()
	fake.CommitTxnStub = nil
	if fake.commitTxnReturnsOnCall == nil {
		fake.commitTxnReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commitTxnReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAsyncProducer) Errors() <-chan *sarama.ProducerError {
	fake.errorsMutex.Lock()
	ret, specificReturn := fake.errorsReturnsOnCall[len(fake.errorsArgsForCall)]
	fake.errorsArgsForCall = append(fake.errorsArgsForCall, struct {
	}{})
	stub := fake.ErrorsStub
	fakeReturns := fake.errorsReturns
	fake.recordInvocation("Errors", []interface{}{})
	fake.errorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) ErrorsCallCount() int {
	fake.errorsMutex.RLock()
	defer fake.errorsMutex.RUnlock()
	return len(fake.errorsArgsForCall)
}

func (fake *FakeAsyncProducer) ErrorsCalls(stub func() <-chan *sarama.ProducerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = stub
}

func (fake *FakeAsyncProducer) ErrorsReturns(result1 <-chan *sarama.ProducerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = nil
	fake.errorsReturns = struct {
		result1 <-chan *sarama.ProducerError
	}{result1}
}

func (fake *FakeAsyncProducer) ErrorsReturnsOnCall(i int, result1 <-chan *sarama.ProducerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = nil
	if fake.errorsReturnsOnCall == nil {
		fake.errorsReturnsOnCall = make(map[int]struct {
			result1 <-chan *sarama.ProducerError
		})
	}
	fake.errorsReturnsOnCall[i] = struct {
		result1 <-chan *sarama.ProducerError
	}{result1}
}

func (fake *FakeAsyncProducer) Input() chan<- *sarama.ProducerMessage {
	fake.inputMutex.Lock()
	ret, specificReturn := fake.inputReturnsOnCall[len(fake.inputArgsForCall)]
	fake.inputArgsForCall = append(fake.inputArgsForCall, struct {
	}{})
	stub := fake.InputStub
	fakeReturns := fake.inputReturns
	fake.recordInvocation("Input", []interface{}{})
	fake.inputMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) InputCallCount() int {
	fake.inputMutex.RLock()
	defer fake.inputMutex.RUnlock()
	return len(fake.inputArgsForCall)
}

func (fake *FakeAsyncProducer) InputCalls(stub func() chan<- *sarama.ProducerMessage) {
	fake.inputMutex.Lock()
	defer fake.inputMutex.Unlock()
	fake.InputStub = stub
}

func (fake *FakeAsyncProducer) InputReturns(result1 chan<- *sarama.ProducerMessage) {
	fake.inputMutex.Lock()
	defer fake.inputMutex.Unlock()
	fake.InputStub = nil
	fake.inputReturns = struct {
		result1 chan<- *sarama.ProducerMessage
	}{result1}
}

func (fake *FakeAsyncProducer) InputReturnsOnCall(i int, result1 chan<- *sarama.ProducerMessage) {
	fake.inputMutex.Lock()
	defer fake.inputMutex.Unlock()
	fake.InputStub = nil
	if fake.inputReturnsOnCall == nil {
		fake.inputReturnsOnCall = make(map[int]struct {
			result1 chan<- *sarama.ProducerMessage
		})
	}
	fake.inputReturnsOnCall[i] = struct {
		result1 chan<- *sarama.ProducerMessage
	}{result1}
}

func (fake *FakeAsyncProducer) IsTransactional() bool {
	fake.isTransactionalMutex.Lock()
	ret, specificReturn := fake.isTransactionalReturnsOnCall[len(fake.isTransactionalArgsForCall)]
	fake.isTransactionalArgsForCall = append(fake.isTransactionalArgsForCall, struct {
	}{})
	stub := fake.IsTransactionalStub
	fakeReturns := fake.isTransactionalReturns
	fake.recordInvocation("IsTransactional", []interface{}{})
	fake.isTransactionalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) IsTransactionalCallCount() int {
	fake.isTransactionalMutex.RLock()
	defer fake.isTransactionalMutex.RUnlock()
	return len(fake.isTransactionalArgsForCall)
}

func (fake *FakeAsyncProducer) IsTransactionalCalls(stub func() bool) {
	fake.isTransactionalMutex.Lock()
	defer fake.isTransactionalMutex.Unlock()
	fake.IsTransactionalStub = stub
}

func (fake *FakeAsyncProducer) IsTransactionalReturns(result1 bool) {
	fake.isTransactionalMutex.Lock()
	defer fake.isTransactionalMutex.Unlock()
	fake.IsTransactionalStub = nil
	fake.isTransactionalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAsyncProducer) IsTransactionalReturnsOnCall(i int, result1 bool) {
	fake.isTransactionalMutex.Lock()
	defer fake.isTransactionalMutex.Unlock()
	fake.IsTransactionalStub = nil
	if fake.isTransactionalReturnsOnCall == nil {
		fake.isTransactionalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isTransactionalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAsyncProducer) Successes() <-chan *sarama.ProducerMessage {
	fake.successesMutex.Lock()
	ret, specificReturn := fake.successesReturnsOnCall[len(fake.successesArgsForCall)]
	fake.successesArgsForCall = append(fake.successesArgsForCall, struct {
	}{})
	stub := fake.SuccessesStub
	fakeReturns := fake.successesReturns
	fake.recordInvocation("Successes", []interface{}{})
	fake.successesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) SuccessesCallCount() int {
	fake.successesMutex.RLock()
	defer fake.successesMutex.RUnlock()
	return len(fake.successesArgsForCall)
}

func (fake *FakeAsyncProducer) SuccessesCalls(stub func() <-chan *sarama.ProducerMessage) {
	fake.successesMutex.Lock()
	defer fake.successesMutex.Unlock()
	fake.SuccessesStub = stub
}

func (fake *FakeAsyncProducer) SuccessesReturns(result1 <-chan *sarama.ProducerMessage) {
	fake.successesMutex.Lock()
	defer fake.successesMutex.Unlock()
	fake.SuccessesStub = nil
	fake.successesReturns = struct {
		result1 <-chan *sarama.ProducerMessage
	}{result1}
}

func (fake *FakeAsyncProducer) SuccessesReturnsOnCall(i int, result1 <-chan *sarama.ProducerMessage) {
	fake.successesMutex.Lock()
	defer fake.successesMutex.Unlock()
	fake.SuccessesStub = nil
	if fake.successesReturnsOnCall == nil {
		fake.successesReturnsOnCall = make(map[int]struct {
			result1 <-chan *sarama.ProducerMessage
		})
	}
	fake.successesReturnsOnCall[i] = struct {
		result1 <-chan *sarama.ProducerMessage
	}{result1}
}

func (fake *FakeAsyncProducer) TxnStatus() sarama.ProducerTxnStatusFlag {
	fake.txnStatusMutex.Lock()
	ret, specificReturn := fake.txnStatusReturnsOnCall[len(fake.txnStatusArgsForCall)]
	fake.txnStatusArgsForCall = append(fake.txnStatusArgsForCall, struct {
	}{})
	stub := fake.TxnStatusStub
	fakeReturns := fake.txnStatusReturns
	fake.recordInvocation("TxnStatus", []interface{}{})
	fake.txnStatusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAsyncProducer) TxnStatusCallCount() int {
	fake.txnStatusMutex.RLock()
	defer fake.txnStatusMutex.RUnlock()
	return len(fake.txnStatusArgsForCall)
}

func (fake *FakeAsyncProducer) TxnStatusCalls(stub func() sarama.ProducerTxnStatusFlag) {
	fake.txnStatusMutex.Lock()
	defer fake.txnStatusMutex.Unlock()
	fake.TxnStatusStub = stub
}

func (fake *FakeAsyncProducer) TxnStatusReturns(result1 sarama.ProducerTxnStatusFlag) {
	fake.txnStatusMutex.Lock()
	defer fake.txnStatusMutex.Unlock()
	fake.TxnStatusStub = nil
	fake.txnStatusReturns = struct {
		result1 sarama.ProducerTxnStatusFlag
	}{result1}
}

func (fake *FakeAsyncProducer) TxnStatusReturnsOnCall(i int, result1 sarama.ProducerTxnStatusFlag) {
	fake.txnStatusMutex.Lock()
	defer fake.txnStatusMutex.Unlock()
	fake.TxnStatusStub = nil
	if fake.txnStatusReturnsOnCall == nil {
		fake.txnStatusReturnsOnCall = make(map[int]struct {
			result1 sarama.ProducerTxnStatusFlag
		})
	}
	fake.txnStatusReturnsOnCall[i] = struct {
		result1 sarama.ProducerTxnStatusFlag
	}{result1}
}

func (fake *FakeAsyncProducer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.abortTxnMutex.RLock()
	defer fake.abortTxnMutex.RUnlock()
	fake.addMessageToTxnMutex.RLock()
	defer fake.addMessageToTxnMutex.RUnlock()
	fake.addOffsetsToTxnMutex.RLock()
	defer fake.addOffsetsToTxnMutex.RUnlock()
	fake.asyncCloseMutex.RLock()
	defer fake.asyncCloseMutex.RUnlock()
	fake.beginTxnMutex.RLock()
	defer fake.beginTxnMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.commitTxnMutex.RLock()
	defer fake.commitTxnMutex.RUnlock()
	fake.errorsMutex.RLock()
	defer fake.errorsMutex.RUnlock()
	fake.inputMutex.RLock()
	defer fake.inputMutex.RUnlock()
	fake.isTransactionalMutex.RLock()
	defer fake.isTransactionalMutex.RUnlock()
	fake.successesMutex.RLock()
	defer fake.successesMutex.RUnlock()
	fake.txnStatusMutex.RLock()
	defer fake.txnStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAsyncProducer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kafka.AsyncProducer = new(FakeAsyncProducer)

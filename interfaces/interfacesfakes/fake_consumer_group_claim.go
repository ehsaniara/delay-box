// Code generated by counterfeiter. DO NOT EDIT.
package interfacesfakes

import (
	"sync"

	"github.com/IBM/sarama"
	"github.com/ehsaniara/delay-box/interfaces"
)

type FakeConsumerGroupClaim struct {
	HighWaterMarkOffsetStub        func() int64
	highWaterMarkOffsetMutex       sync.RWMutex
	highWaterMarkOffsetArgsForCall []struct {
	}
	highWaterMarkOffsetReturns struct {
		result1 int64
	}
	highWaterMarkOffsetReturnsOnCall map[int]struct {
		result1 int64
	}
	InitialOffsetStub        func() int64
	initialOffsetMutex       sync.RWMutex
	initialOffsetArgsForCall []struct {
	}
	initialOffsetReturns struct {
		result1 int64
	}
	initialOffsetReturnsOnCall map[int]struct {
		result1 int64
	}
	MessagesStub        func() <-chan *sarama.ConsumerMessage
	messagesMutex       sync.RWMutex
	messagesArgsForCall []struct {
	}
	messagesReturns struct {
		result1 <-chan *sarama.ConsumerMessage
	}
	messagesReturnsOnCall map[int]struct {
		result1 <-chan *sarama.ConsumerMessage
	}
	PartitionStub        func() int32
	partitionMutex       sync.RWMutex
	partitionArgsForCall []struct {
	}
	partitionReturns struct {
		result1 int32
	}
	partitionReturnsOnCall map[int]struct {
		result1 int32
	}
	TopicStub        func() string
	topicMutex       sync.RWMutex
	topicArgsForCall []struct {
	}
	topicReturns struct {
		result1 string
	}
	topicReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConsumerGroupClaim) HighWaterMarkOffset() int64 {
	fake.highWaterMarkOffsetMutex.Lock()
	ret, specificReturn := fake.highWaterMarkOffsetReturnsOnCall[len(fake.highWaterMarkOffsetArgsForCall)]
	fake.highWaterMarkOffsetArgsForCall = append(fake.highWaterMarkOffsetArgsForCall, struct {
	}{})
	stub := fake.HighWaterMarkOffsetStub
	fakeReturns := fake.highWaterMarkOffsetReturns
	fake.recordInvocation("HighWaterMarkOffset", []interface{}{})
	fake.highWaterMarkOffsetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupClaim) HighWaterMarkOffsetCallCount() int {
	fake.highWaterMarkOffsetMutex.RLock()
	defer fake.highWaterMarkOffsetMutex.RUnlock()
	return len(fake.highWaterMarkOffsetArgsForCall)
}

func (fake *FakeConsumerGroupClaim) HighWaterMarkOffsetCalls(stub func() int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = stub
}

func (fake *FakeConsumerGroupClaim) HighWaterMarkOffsetReturns(result1 int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = nil
	fake.highWaterMarkOffsetReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeConsumerGroupClaim) HighWaterMarkOffsetReturnsOnCall(i int, result1 int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = nil
	if fake.highWaterMarkOffsetReturnsOnCall == nil {
		fake.highWaterMarkOffsetReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.highWaterMarkOffsetReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeConsumerGroupClaim) InitialOffset() int64 {
	fake.initialOffsetMutex.Lock()
	ret, specificReturn := fake.initialOffsetReturnsOnCall[len(fake.initialOffsetArgsForCall)]
	fake.initialOffsetArgsForCall = append(fake.initialOffsetArgsForCall, struct {
	}{})
	stub := fake.InitialOffsetStub
	fakeReturns := fake.initialOffsetReturns
	fake.recordInvocation("InitialOffset", []interface{}{})
	fake.initialOffsetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupClaim) InitialOffsetCallCount() int {
	fake.initialOffsetMutex.RLock()
	defer fake.initialOffsetMutex.RUnlock()
	return len(fake.initialOffsetArgsForCall)
}

func (fake *FakeConsumerGroupClaim) InitialOffsetCalls(stub func() int64) {
	fake.initialOffsetMutex.Lock()
	defer fake.initialOffsetMutex.Unlock()
	fake.InitialOffsetStub = stub
}

func (fake *FakeConsumerGroupClaim) InitialOffsetReturns(result1 int64) {
	fake.initialOffsetMutex.Lock()
	defer fake.initialOffsetMutex.Unlock()
	fake.InitialOffsetStub = nil
	fake.initialOffsetReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeConsumerGroupClaim) InitialOffsetReturnsOnCall(i int, result1 int64) {
	fake.initialOffsetMutex.Lock()
	defer fake.initialOffsetMutex.Unlock()
	fake.InitialOffsetStub = nil
	if fake.initialOffsetReturnsOnCall == nil {
		fake.initialOffsetReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.initialOffsetReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeConsumerGroupClaim) Messages() <-chan *sarama.ConsumerMessage {
	fake.messagesMutex.Lock()
	ret, specificReturn := fake.messagesReturnsOnCall[len(fake.messagesArgsForCall)]
	fake.messagesArgsForCall = append(fake.messagesArgsForCall, struct {
	}{})
	stub := fake.MessagesStub
	fakeReturns := fake.messagesReturns
	fake.recordInvocation("Messages", []interface{}{})
	fake.messagesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupClaim) MessagesCallCount() int {
	fake.messagesMutex.RLock()
	defer fake.messagesMutex.RUnlock()
	return len(fake.messagesArgsForCall)
}

func (fake *FakeConsumerGroupClaim) MessagesCalls(stub func() <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = stub
}

func (fake *FakeConsumerGroupClaim) MessagesReturns(result1 <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	fake.messagesReturns = struct {
		result1 <-chan *sarama.ConsumerMessage
	}{result1}
}

func (fake *FakeConsumerGroupClaim) MessagesReturnsOnCall(i int, result1 <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	if fake.messagesReturnsOnCall == nil {
		fake.messagesReturnsOnCall = make(map[int]struct {
			result1 <-chan *sarama.ConsumerMessage
		})
	}
	fake.messagesReturnsOnCall[i] = struct {
		result1 <-chan *sarama.ConsumerMessage
	}{result1}
}

func (fake *FakeConsumerGroupClaim) Partition() int32 {
	fake.partitionMutex.Lock()
	ret, specificReturn := fake.partitionReturnsOnCall[len(fake.partitionArgsForCall)]
	fake.partitionArgsForCall = append(fake.partitionArgsForCall, struct {
	}{})
	stub := fake.PartitionStub
	fakeReturns := fake.partitionReturns
	fake.recordInvocation("Partition", []interface{}{})
	fake.partitionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupClaim) PartitionCallCount() int {
	fake.partitionMutex.RLock()
	defer fake.partitionMutex.RUnlock()
	return len(fake.partitionArgsForCall)
}

func (fake *FakeConsumerGroupClaim) PartitionCalls(stub func() int32) {
	fake.partitionMutex.Lock()
	defer fake.partitionMutex.Unlock()
	fake.PartitionStub = stub
}

func (fake *FakeConsumerGroupClaim) PartitionReturns(result1 int32) {
	fake.partitionMutex.Lock()
	defer fake.partitionMutex.Unlock()
	fake.PartitionStub = nil
	fake.partitionReturns = struct {
		result1 int32
	}{result1}
}

func (fake *FakeConsumerGroupClaim) PartitionReturnsOnCall(i int, result1 int32) {
	fake.partitionMutex.Lock()
	defer fake.partitionMutex.Unlock()
	fake.PartitionStub = nil
	if fake.partitionReturnsOnCall == nil {
		fake.partitionReturnsOnCall = make(map[int]struct {
			result1 int32
		})
	}
	fake.partitionReturnsOnCall[i] = struct {
		result1 int32
	}{result1}
}

func (fake *FakeConsumerGroupClaim) Topic() string {
	fake.topicMutex.Lock()
	ret, specificReturn := fake.topicReturnsOnCall[len(fake.topicArgsForCall)]
	fake.topicArgsForCall = append(fake.topicArgsForCall, struct {
	}{})
	stub := fake.TopicStub
	fakeReturns := fake.topicReturns
	fake.recordInvocation("Topic", []interface{}{})
	fake.topicMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupClaim) TopicCallCount() int {
	fake.topicMutex.RLock()
	defer fake.topicMutex.RUnlock()
	return len(fake.topicArgsForCall)
}

func (fake *FakeConsumerGroupClaim) TopicCalls(stub func() string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = stub
}

func (fake *FakeConsumerGroupClaim) TopicReturns(result1 string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = nil
	fake.topicReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConsumerGroupClaim) TopicReturnsOnCall(i int, result1 string) {
	fake.topicMutex.Lock()
	defer fake.topicMutex.Unlock()
	fake.TopicStub = nil
	if fake.topicReturnsOnCall == nil {
		fake.topicReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.topicReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConsumerGroupClaim) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.highWaterMarkOffsetMutex.RLock()
	defer fake.highWaterMarkOffsetMutex.RUnlock()
	fake.initialOffsetMutex.RLock()
	defer fake.initialOffsetMutex.RUnlock()
	fake.messagesMutex.RLock()
	defer fake.messagesMutex.RUnlock()
	fake.partitionMutex.RLock()
	defer fake.partitionMutex.RUnlock()
	fake.topicMutex.RLock()
	defer fake.topicMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConsumerGroupClaim) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ interfaces.ConsumerGroupClaim = new(FakeConsumerGroupClaim)

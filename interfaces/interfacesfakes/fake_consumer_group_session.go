// Code generated by counterfeiter. DO NOT EDIT.
package interfacesfakes

import (
	"context"
	"sync"

	"github.com/IBM/sarama"
	"github.com/ehsaniara/scheduler/interfaces"
)

type FakeConsumerGroupSession struct {
	ClaimsStub        func() map[string][]int32
	claimsMutex       sync.RWMutex
	claimsArgsForCall []struct {
	}
	claimsReturns struct {
		result1 map[string][]int32
	}
	claimsReturnsOnCall map[int]struct {
		result1 map[string][]int32
	}
	CommitStub        func()
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
	}
	ContextStub        func() context.Context
	contextMutex       sync.RWMutex
	contextArgsForCall []struct {
	}
	contextReturns struct {
		result1 context.Context
	}
	contextReturnsOnCall map[int]struct {
		result1 context.Context
	}
	GenerationIDStub        func() int32
	generationIDMutex       sync.RWMutex
	generationIDArgsForCall []struct {
	}
	generationIDReturns struct {
		result1 int32
	}
	generationIDReturnsOnCall map[int]struct {
		result1 int32
	}
	MarkMessageStub        func(*sarama.ConsumerMessage, string)
	markMessageMutex       sync.RWMutex
	markMessageArgsForCall []struct {
		arg1 *sarama.ConsumerMessage
		arg2 string
	}
	MarkOffsetStub        func(string, int32, int64, string)
	markOffsetMutex       sync.RWMutex
	markOffsetArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 int64
		arg4 string
	}
	MemberIDStub        func() string
	memberIDMutex       sync.RWMutex
	memberIDArgsForCall []struct {
	}
	memberIDReturns struct {
		result1 string
	}
	memberIDReturnsOnCall map[int]struct {
		result1 string
	}
	ResetOffsetStub        func(string, int32, int64, string)
	resetOffsetMutex       sync.RWMutex
	resetOffsetArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 int64
		arg4 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConsumerGroupSession) Claims() map[string][]int32 {
	fake.claimsMutex.Lock()
	ret, specificReturn := fake.claimsReturnsOnCall[len(fake.claimsArgsForCall)]
	fake.claimsArgsForCall = append(fake.claimsArgsForCall, struct {
	}{})
	stub := fake.ClaimsStub
	fakeReturns := fake.claimsReturns
	fake.recordInvocation("Claims", []interface{}{})
	fake.claimsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupSession) ClaimsCallCount() int {
	fake.claimsMutex.RLock()
	defer fake.claimsMutex.RUnlock()
	return len(fake.claimsArgsForCall)
}

func (fake *FakeConsumerGroupSession) ClaimsCalls(stub func() map[string][]int32) {
	fake.claimsMutex.Lock()
	defer fake.claimsMutex.Unlock()
	fake.ClaimsStub = stub
}

func (fake *FakeConsumerGroupSession) ClaimsReturns(result1 map[string][]int32) {
	fake.claimsMutex.Lock()
	defer fake.claimsMutex.Unlock()
	fake.ClaimsStub = nil
	fake.claimsReturns = struct {
		result1 map[string][]int32
	}{result1}
}

func (fake *FakeConsumerGroupSession) ClaimsReturnsOnCall(i int, result1 map[string][]int32) {
	fake.claimsMutex.Lock()
	defer fake.claimsMutex.Unlock()
	fake.ClaimsStub = nil
	if fake.claimsReturnsOnCall == nil {
		fake.claimsReturnsOnCall = make(map[int]struct {
			result1 map[string][]int32
		})
	}
	fake.claimsReturnsOnCall[i] = struct {
		result1 map[string][]int32
	}{result1}
}

func (fake *FakeConsumerGroupSession) Commit() {
	fake.commitMutex.Lock()
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
	}{})
	stub := fake.CommitStub
	fake.recordInvocation("Commit", []interface{}{})
	fake.commitMutex.Unlock()
	if stub != nil {
		fake.CommitStub()
	}
}

func (fake *FakeConsumerGroupSession) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeConsumerGroupSession) CommitCalls(stub func()) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *FakeConsumerGroupSession) Context() context.Context {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct {
	}{})
	stub := fake.ContextStub
	fakeReturns := fake.contextReturns
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupSession) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *FakeConsumerGroupSession) ContextCalls(stub func() context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = stub
}

func (fake *FakeConsumerGroupSession) ContextReturns(result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 context.Context
	}{result1}
}

func (fake *FakeConsumerGroupSession) ContextReturnsOnCall(i int, result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 context.Context
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 context.Context
	}{result1}
}

func (fake *FakeConsumerGroupSession) GenerationID() int32 {
	fake.generationIDMutex.Lock()
	ret, specificReturn := fake.generationIDReturnsOnCall[len(fake.generationIDArgsForCall)]
	fake.generationIDArgsForCall = append(fake.generationIDArgsForCall, struct {
	}{})
	stub := fake.GenerationIDStub
	fakeReturns := fake.generationIDReturns
	fake.recordInvocation("GenerationID", []interface{}{})
	fake.generationIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupSession) GenerationIDCallCount() int {
	fake.generationIDMutex.RLock()
	defer fake.generationIDMutex.RUnlock()
	return len(fake.generationIDArgsForCall)
}

func (fake *FakeConsumerGroupSession) GenerationIDCalls(stub func() int32) {
	fake.generationIDMutex.Lock()
	defer fake.generationIDMutex.Unlock()
	fake.GenerationIDStub = stub
}

func (fake *FakeConsumerGroupSession) GenerationIDReturns(result1 int32) {
	fake.generationIDMutex.Lock()
	defer fake.generationIDMutex.Unlock()
	fake.GenerationIDStub = nil
	fake.generationIDReturns = struct {
		result1 int32
	}{result1}
}

func (fake *FakeConsumerGroupSession) GenerationIDReturnsOnCall(i int, result1 int32) {
	fake.generationIDMutex.Lock()
	defer fake.generationIDMutex.Unlock()
	fake.GenerationIDStub = nil
	if fake.generationIDReturnsOnCall == nil {
		fake.generationIDReturnsOnCall = make(map[int]struct {
			result1 int32
		})
	}
	fake.generationIDReturnsOnCall[i] = struct {
		result1 int32
	}{result1}
}

func (fake *FakeConsumerGroupSession) MarkMessage(arg1 *sarama.ConsumerMessage, arg2 string) {
	fake.markMessageMutex.Lock()
	fake.markMessageArgsForCall = append(fake.markMessageArgsForCall, struct {
		arg1 *sarama.ConsumerMessage
		arg2 string
	}{arg1, arg2})
	stub := fake.MarkMessageStub
	fake.recordInvocation("MarkMessage", []interface{}{arg1, arg2})
	fake.markMessageMutex.Unlock()
	if stub != nil {
		fake.MarkMessageStub(arg1, arg2)
	}
}

func (fake *FakeConsumerGroupSession) MarkMessageCallCount() int {
	fake.markMessageMutex.RLock()
	defer fake.markMessageMutex.RUnlock()
	return len(fake.markMessageArgsForCall)
}

func (fake *FakeConsumerGroupSession) MarkMessageCalls(stub func(*sarama.ConsumerMessage, string)) {
	fake.markMessageMutex.Lock()
	defer fake.markMessageMutex.Unlock()
	fake.MarkMessageStub = stub
}

func (fake *FakeConsumerGroupSession) MarkMessageArgsForCall(i int) (*sarama.ConsumerMessage, string) {
	fake.markMessageMutex.RLock()
	defer fake.markMessageMutex.RUnlock()
	argsForCall := fake.markMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeConsumerGroupSession) MarkOffset(arg1 string, arg2 int32, arg3 int64, arg4 string) {
	fake.markOffsetMutex.Lock()
	fake.markOffsetArgsForCall = append(fake.markOffsetArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 int64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.MarkOffsetStub
	fake.recordInvocation("MarkOffset", []interface{}{arg1, arg2, arg3, arg4})
	fake.markOffsetMutex.Unlock()
	if stub != nil {
		fake.MarkOffsetStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeConsumerGroupSession) MarkOffsetCallCount() int {
	fake.markOffsetMutex.RLock()
	defer fake.markOffsetMutex.RUnlock()
	return len(fake.markOffsetArgsForCall)
}

func (fake *FakeConsumerGroupSession) MarkOffsetCalls(stub func(string, int32, int64, string)) {
	fake.markOffsetMutex.Lock()
	defer fake.markOffsetMutex.Unlock()
	fake.MarkOffsetStub = stub
}

func (fake *FakeConsumerGroupSession) MarkOffsetArgsForCall(i int) (string, int32, int64, string) {
	fake.markOffsetMutex.RLock()
	defer fake.markOffsetMutex.RUnlock()
	argsForCall := fake.markOffsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeConsumerGroupSession) MemberID() string {
	fake.memberIDMutex.Lock()
	ret, specificReturn := fake.memberIDReturnsOnCall[len(fake.memberIDArgsForCall)]
	fake.memberIDArgsForCall = append(fake.memberIDArgsForCall, struct {
	}{})
	stub := fake.MemberIDStub
	fakeReturns := fake.memberIDReturns
	fake.recordInvocation("MemberID", []interface{}{})
	fake.memberIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConsumerGroupSession) MemberIDCallCount() int {
	fake.memberIDMutex.RLock()
	defer fake.memberIDMutex.RUnlock()
	return len(fake.memberIDArgsForCall)
}

func (fake *FakeConsumerGroupSession) MemberIDCalls(stub func() string) {
	fake.memberIDMutex.Lock()
	defer fake.memberIDMutex.Unlock()
	fake.MemberIDStub = stub
}

func (fake *FakeConsumerGroupSession) MemberIDReturns(result1 string) {
	fake.memberIDMutex.Lock()
	defer fake.memberIDMutex.Unlock()
	fake.MemberIDStub = nil
	fake.memberIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConsumerGroupSession) MemberIDReturnsOnCall(i int, result1 string) {
	fake.memberIDMutex.Lock()
	defer fake.memberIDMutex.Unlock()
	fake.MemberIDStub = nil
	if fake.memberIDReturnsOnCall == nil {
		fake.memberIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.memberIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConsumerGroupSession) ResetOffset(arg1 string, arg2 int32, arg3 int64, arg4 string) {
	fake.resetOffsetMutex.Lock()
	fake.resetOffsetArgsForCall = append(fake.resetOffsetArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 int64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ResetOffsetStub
	fake.recordInvocation("ResetOffset", []interface{}{arg1, arg2, arg3, arg4})
	fake.resetOffsetMutex.Unlock()
	if stub != nil {
		fake.ResetOffsetStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeConsumerGroupSession) ResetOffsetCallCount() int {
	fake.resetOffsetMutex.RLock()
	defer fake.resetOffsetMutex.RUnlock()
	return len(fake.resetOffsetArgsForCall)
}

func (fake *FakeConsumerGroupSession) ResetOffsetCalls(stub func(string, int32, int64, string)) {
	fake.resetOffsetMutex.Lock()
	defer fake.resetOffsetMutex.Unlock()
	fake.ResetOffsetStub = stub
}

func (fake *FakeConsumerGroupSession) ResetOffsetArgsForCall(i int) (string, int32, int64, string) {
	fake.resetOffsetMutex.RLock()
	defer fake.resetOffsetMutex.RUnlock()
	argsForCall := fake.resetOffsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeConsumerGroupSession) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.claimsMutex.RLock()
	defer fake.claimsMutex.RUnlock()
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.generationIDMutex.RLock()
	defer fake.generationIDMutex.RUnlock()
	fake.markMessageMutex.RLock()
	defer fake.markMessageMutex.RUnlock()
	fake.markOffsetMutex.RLock()
	defer fake.markOffsetMutex.RUnlock()
	fake.memberIDMutex.RLock()
	defer fake.memberIDMutex.RUnlock()
	fake.resetOffsetMutex.RLock()
	defer fake.resetOffsetMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConsumerGroupSession) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ interfaces.ConsumerGroupSession = new(FakeConsumerGroupSession)
